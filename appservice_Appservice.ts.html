

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> appservice/Appservice.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                <div class="dropdown is-hoverable is-right">
                    <a class="dropdown-trigger link">
                        Tutorials
                        <i class="fas fa-chevron-down fa-xs"></i>
                    </a>
                    <div class="dropdown-menu">
                        <div class="dropdown-content">
                        
                            <a class="dropdown-item" href="tutorial-appservice_.html">
                                Appservice (bridge) usage
                            </a>
                        
                            <a class="dropdown-item" href="tutorial-bot.html">
                                Bot usage
                            </a>
                        
                            <a class="dropdown-item" href="tutorial-encryption.html">
                                Encryption
                            </a>
                        
                            <a class="dropdown-item" href="tutorial-room-upgrades.html">
                                Room upgrades
                            </a>
                        
                        </div>
                    </div>
                </div>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="Appservice_Appservice.html">Appservice</a></li><li><a href="DMs_DMs.html">DMs</a></li><li><a href="Intent_Intent.html">Intent</a></li><li><a href="MatrixAuth.html">MatrixAuth</a></li><li><a href="MatrixAuth_MatrixAuth.html">MatrixAuth</a></li><li><a href="MatrixClient.html">MatrixClient</a></li><li><a href="MatrixClient_MatrixClient.html">MatrixClient</a></li><li><a href="MatrixEntity_MatrixEntity.html">MatrixEntity</a></li><li><a href="MatrixError_MatrixError.html">MatrixError</a></li><li><a href="MatrixGlob_MatrixGlob.html">MatrixGlob</a></li><li><a href="MatrixProfile_MatrixProfile.html">MatrixProfile</a></li><li><a href="Metrics_Metrics.html">Metrics</a></li><li><a href="PantalaimonClient_PantalaimonClient.html">PantalaimonClient</a></li><li><a href="ProfileCache_ProfileCache.html">ProfileCache</a></li><li><a href="RichRepliesPreprocessor_RichRepliesPreprocessor.html">RichRepliesPreprocessor</a></li><li><a href="RustEngine.html">RustEngine</a></li><li><a href="RustSdkAppserviceCryptoStorageProvider_RustSdkAppserviceCryptoStorageProvider.html">RustSdkAppserviceCryptoStorageProvider</a></li><li><a href="RustSdkCryptoStorageProvider_RustSdkCryptoStorageProvider.html">RustSdkCryptoStorageProvider</a></li><li><a href="SimpleFsStorageProvider_SimpleFsStorageProvider.html">SimpleFsStorageProvider</a></li><li><a href="SynchronousMatrixClient.html">SynchronousMatrixClient</a></li><li><a href="SynchronousMatrixClient_SynchronousMatrixClient.html">SynchronousMatrixClient</a></li></ul><h3>Interfaces</h3><ul><li><a href="IFilterInfo.html">IFilterInfo</a></li><li><a href="PowerLevelBounds.html">PowerLevelBounds</a></li></ul><h3>Global</h3><ul><li><a href="global.html#PowerLevelAction">PowerLevelAction</a></li><li><a href="global.html#SYNC_LOCK_NAME">SYNC_LOCK_NAME</a></li></ul></div><div class="category"><h2>Admin APIs</h2><h3>Classes</h3><ul><li><a href="AdminApis.html">AdminApis</a></li><li><a href="SynapseAdminApis.html">SynapseAdminApis</a></li></ul><h3>Interfaces</h3><ul><li><a href="SynapseRegistrationToken.html">SynapseRegistrationToken</a></li><li><a href="SynapseRoomList.html">SynapseRoomList</a></li><li><a href="SynapseRoomListing.html">SynapseRoomListing</a></li><li><a href="SynapseUser.html">SynapseUser</a></li><li><a href="SynapseUserList.html">SynapseUserList</a></li><li><a href="SynapseUserListing.html">SynapseUserListing</a></li><li><a href="SynapseUserProperties.html">SynapseUserProperties</a></li><li><a href="WhoisInfo.html">WhoisInfo</a></li></ul><h3>Global</h3><ul><li><a href="global.html#SynapseRoomProperty">SynapseRoomProperty</a></li></ul></div><div class="category"><h2>Application services</h2><h3>Classes</h3><ul><li><a href="Appservice.html">Appservice</a></li><li><a href="Intent.html">Intent</a></li><li><a href="MatrixBridge.html">MatrixBridge</a></li></ul><h3>Interfaces</h3><ul><li><a href="IApplicationServiceProtocol.html">IApplicationServiceProtocol</a></li><li><a href="IAppserviceOptions.html">IAppserviceOptions</a></li><li><a href="IAppserviceRegistration.html">IAppserviceRegistration</a></li><li><a href="IRemoteRoomInfo.html">IRemoteRoomInfo</a></li><li><a href="IRemoteUserInfo.html">IRemoteUserInfo</a></li><li><a href="MSC3983KeyClaimResponse.html">MSC3983KeyClaimResponse</a></li><li><a href="MSC3984KeyQueryResponse.html">MSC3984KeyQueryResponse</a></li></ul></div><div class="category"><h2>Encryption</h2><h3>Classes</h3><ul><li><a href="CryptoClient.html">CryptoClient</a></li><li><a href="PantalaimonClient.html">PantalaimonClient</a></li><li><a href="RoomTracker.html">RoomTracker</a></li></ul><h3>Interfaces</h3><ul><li><a href="ICryptoRoomInformation.html">ICryptoRoomInformation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#requiresCrypto">requiresCrypto</a></li><li><a href="global.html#requiresReady">requiresReady</a></li></ul></div><div class="category"><h2>Error handling</h2><h3>Classes</h3><ul><li><a href="MatrixError.html">MatrixError</a></li></ul></div><div class="category"><h2>Identity Servers</h2><h3>Classes</h3><ul><li><a href="IdentityClient.html">IdentityClient</a></li></ul></div><div class="category"><h2>Join strategies</h2><h3>Classes</h3><ul><li><a href="AppserviceJoinRoomStrategy.html">AppserviceJoinRoomStrategy</a></li><li><a href="SimpleRetryJoinStrategy.html">SimpleRetryJoinStrategy</a></li></ul></div><div class="category"><h2>Logging</h2><h3>Classes</h3><ul><li><a href="ConsoleLogger.html">ConsoleLogger</a></li><li><a href="LogLevel.html">LogLevel</a></li><li><a href="LogService.html">LogService</a></li><li><a href="RichConsoleLogger.html">RichConsoleLogger</a></li></ul><h3>Interfaces</h3><ul><li><a href="ILogger.html">ILogger</a></li></ul><h3>Global</h3><ul><li><a href="global.html#extractRequestError">extractRequestError</a></li></ul></div><div class="category"><h2>Matrix event contents</h2><h3>Interfaces</h3><ul><li><a href="AliasesEventContent.html">AliasesEventContent</a></li><li><a href="AudioMessageEventContent.html">AudioMessageEventContent</a></li><li><a href="CanonicalAliasEventContent.html">CanonicalAliasEventContent</a></li><li><a href="CreateEventContent.html">CreateEventContent</a></li><li><a href="EncryptedFile.html">EncryptedFile</a></li><li><a href="EncryptedRoomEventContent.html">EncryptedRoomEventContent</a></li><li><a href="EncryptionEventContent.html">EncryptionEventContent</a></li><li><a href="FileMessageEventContent.html">FileMessageEventContent</a></li><li><a href="ImageMessageEventContent.html">ImageMessageEventContent</a></li><li><a href="JoinRulesEventContent.html">JoinRulesEventContent</a></li><li><a href="LocationMessageEventContent.html">LocationMessageEventContent</a></li><li><a href="MembershipEventContent.html">MembershipEventContent</a></li><li><a href="MessageEventContent.html">MessageEventContent</a></li><li><a href="MSC2716ChunkEventContent.html">MSC2716ChunkEventContent</a></li><li><a href="MSC2716InsertionEventContent.html">MSC2716InsertionEventContent</a></li><li><a href="MSC2716MarkerEventContent.html">MSC2716MarkerEventContent</a></li><li><a href="PinnedEventsEventContent.html">PinnedEventsEventContent</a></li><li><a href="PowerLevelsEventContent.html">PowerLevelsEventContent</a></li><li><a href="PresenceEventContent.html">PresenceEventContent</a></li><li><a href="RedactionEventContent.html">RedactionEventContent</a></li><li><a href="RoomAvatarEventContent.html">RoomAvatarEventContent</a></li><li><a href="RoomEventContent.html">RoomEventContent</a></li><li><a href="RoomNameEventContent.html">RoomNameEventContent</a></li><li><a href="RoomTopicEventContent.html">RoomTopicEventContent</a></li><li><a href="SpaceChildEventContent.html">SpaceChildEventContent</a></li><li><a href="TextualMessageEventContent.html">TextualMessageEventContent</a></li><li><a href="VideoMessageEventContent.html">VideoMessageEventContent</a></li></ul></div><div class="category"><h2>Matrix event info</h2><h3>Interfaces</h3><ul><li><a href="DimensionalFileInfo.html">DimensionalFileInfo</a></li><li><a href="FileInfo.html">FileInfo</a></li><li><a href="FileWithThumbnailInfo.html">FileWithThumbnailInfo</a></li><li><a href="PreviousRoomInfo.html">PreviousRoomInfo</a></li><li><a href="ThumbnailedFileInfo.html">ThumbnailedFileInfo</a></li><li><a href="ThumbnailInfo.html">ThumbnailInfo</a></li><li><a href="TimedFileInfo.html">TimedFileInfo</a></li><li><a href="TypicalUnsigned.html">TypicalUnsigned</a></li><li><a href="VideoFileInfo.html">VideoFileInfo</a></li></ul><h3><a href="global.html">Global</a></h3></div><div class="category"><h2>Matrix events</h2><h3>Classes</h3><ul><li><a href="AliasesEvent.html">AliasesEvent</a></li><li><a href="CanonicalAliasEvent.html">CanonicalAliasEvent</a></li><li><a href="CreateEvent.html">CreateEvent</a></li><li><a href="EncryptedRoomEvent.html">EncryptedRoomEvent</a></li><li><a href="EncryptionEvent.html">EncryptionEvent</a></li><li><a href="EventRedactedError.html">EventRedactedError</a></li><li><a href="InvalidEventError.html">InvalidEventError</a></li><li><a href="JoinRulesEvent.html">JoinRulesEvent</a></li><li><a href="MatrixEvent.html">MatrixEvent</a></li><li><a href="MembershipEvent.html">MembershipEvent</a></li><li><a href="MessageEvent.html">MessageEvent</a></li><li><a href="PinnedEventsEvent.html">PinnedEventsEvent</a></li><li><a href="PowerLevelsEvent.html">PowerLevelsEvent</a></li><li><a href="PresenceEvent.html">PresenceEvent</a></li><li><a href="RedactionEvent.html">RedactionEvent</a></li><li><a href="RoomAvatarEvent.html">RoomAvatarEvent</a></li><li><a href="RoomEvent.html">RoomEvent</a></li><li><a href="RoomNameEvent.html">RoomNameEvent</a></li><li><a href="RoomTopicEvent.html">RoomTopicEvent</a></li><li><a href="SpaceChildEvent.html">SpaceChildEvent</a></li><li><a href="StateEvent.html">StateEvent</a></li></ul><h3>Global</h3><ul><li><a href="global.html#EventKind">EventKind</a></li><li><a href="global.html#wrapRoomEvent">wrapRoomEvent</a></li></ul></div><div class="category"><h2>Metrics</h2><h3>Classes</h3><ul><li><a href="Metrics.html">Metrics</a></li></ul><h3>Interfaces</h3><ul><li><a href="FunctionCallContext.html">FunctionCallContext</a></li><li><a href="IdentityClientCallContext.html">IdentityClientCallContext</a></li><li><a href="IMetricListener.html">IMetricListener</a></li><li><a href="IntentCallContext.html">IntentCallContext</a></li><li><a href="MatrixClientCallContext.html">MatrixClientCallContext</a></li></ul><h3>Global</h3><ul><li><a href="global.html#METRIC_IDENTITY_CLIENT_FAILED_FUNCTION_CALL">METRIC_IDENTITY_CLIENT_FAILED_FUNCTION_CALL</a></li><li><a href="global.html#METRIC_IDENTITY_CLIENT_FUNCTION_CALL">METRIC_IDENTITY_CLIENT_FUNCTION_CALL</a></li><li><a href="global.html#METRIC_IDENTITY_CLIENT_SUCCESSFUL_FUNCTION_CALL">METRIC_IDENTITY_CLIENT_SUCCESSFUL_FUNCTION_CALL</a></li><li><a href="global.html#METRIC_INTENT_FAILED_FUNCTION_CALL">METRIC_INTENT_FAILED_FUNCTION_CALL</a></li><li><a href="global.html#METRIC_INTENT_FUNCTION_CALL">METRIC_INTENT_FUNCTION_CALL</a></li><li><a href="global.html#METRIC_INTENT_SUCCESSFUL_FUNCTION_CALL">METRIC_INTENT_SUCCESSFUL_FUNCTION_CALL</a></li><li><a href="global.html#METRIC_MATRIX_CLIENT_FAILED_FUNCTION_CALL">METRIC_MATRIX_CLIENT_FAILED_FUNCTION_CALL</a></li><li><a href="global.html#METRIC_MATRIX_CLIENT_FUNCTION_CALL">METRIC_MATRIX_CLIENT_FUNCTION_CALL</a></li><li><a href="global.html#METRIC_MATRIX_CLIENT_SUCCESSFUL_FUNCTION_CALL">METRIC_MATRIX_CLIENT_SUCCESSFUL_FUNCTION_CALL</a></li><li><a href="global.html#timedIdentityClientFunctionCall">timedIdentityClientFunctionCall</a></li><li><a href="global.html#timedIntentFunctionCall">timedIntentFunctionCall</a></li><li><a href="global.html#timedMatrixClientFunctionCall">timedMatrixClientFunctionCall</a></li></ul></div><div class="category"><h2>Mixins</h2><h3>Classes</h3><ul><li><a href="AutojoinRoomsMixin.html">AutojoinRoomsMixin</a></li><li><a href="AutojoinUpgradedRoomsMixin.html">AutojoinUpgradedRoomsMixin</a></li></ul></div><div class="category"><h2>Models</h2><h3>Classes</h3><ul><li><a href="MatrixProfile.html">MatrixProfile</a></li><li><a href="Presence.html">Presence</a></li><li><a href="Space.html">Space</a></li></ul><h3>Interfaces</h3><ul><li><a href="FallbackKey.html">FallbackKey</a></li><li><a href="IdentityServerAccount.html">IdentityServerAccount</a></li><li><a href="IdentityServerInvite.html">IdentityServerInvite</a></li><li><a href="IMegolmEncrypted.html">IMegolmEncrypted</a></li><li><a href="IOlmEncrypted.html">IOlmEncrypted</a></li><li><a href="IToDeviceMessage.html">IToDeviceMessage</a></li><li><a href="IWhoAmI.html">IWhoAmI</a></li><li><a href="MatrixProfileInfo.html">MatrixProfileInfo</a></li><li><a href="MSC2716BatchSendResponse.html">MSC2716BatchSendResponse</a></li><li><a href="MultiUserDeviceListResponse.html">MultiUserDeviceListResponse</a></li><li><a href="OpenIDConnectToken.html">OpenIDConnectToken</a></li><li><a href="OTKClaimResponse.html">OTKClaimResponse</a></li><li><a href="OwnUserDevice.html">OwnUserDevice</a></li><li><a href="Policies.html">Policies</a></li><li><a href="Policy.html">Policy</a></li><li><a href="RoomCreateOptions.html">RoomCreateOptions</a></li><li><a href="Signatures.html">Signatures</a></li><li><a href="SignedCurve25519OTK.html">SignedCurve25519OTK</a></li><li><a href="SpaceChildEntityOptions.html">SpaceChildEntityOptions</a></li><li><a href="SpaceCreateOptions.html">SpaceCreateOptions</a></li><li><a href="SpaceEntityMap.html">SpaceEntityMap</a></li><li><a href="Threepid.html">Threepid</a></li><li><a href="TranslatedPolicy.html">TranslatedPolicy</a></li><li><a href="UserDevice.html">UserDevice</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DeviceKeyAlgorithm">DeviceKeyAlgorithm</a></li><li><a href="global.html#EncryptionAlgorithm">EncryptionAlgorithm</a></li><li><a href="global.html#OTKAlgorithm">OTKAlgorithm</a></li><li><a href="global.html#RoomEncryptionAlgorithm">RoomEncryptionAlgorithm</a></li></ul></div><div class="category"><h2>Preprocessors</h2><h3>Classes</h3><ul><li><a href="RichRepliesPreprocessor.html">RichRepliesPreprocessor</a></li></ul><h3>Interfaces</h3><ul><li><a href="IPreprocessor.html">IPreprocessor</a></li><li><a href="IRichReplyMetadata.html">IRichReplyMetadata</a></li></ul></div><div class="category"><h2>Storage providers</h2><h3>Classes</h3><ul><li><a href="MemoryStorageProvider.html">MemoryStorageProvider</a></li><li><a href="NamespacedFsProvider.html">NamespacedFsProvider</a></li><li><a href="RustSdkAppserviceCryptoStorageProvider.html">RustSdkAppserviceCryptoStorageProvider</a></li><li><a href="RustSdkCryptoStorageProvider.html">RustSdkCryptoStorageProvider</a></li><li><a href="SimpleFsStorageProvider.html">SimpleFsStorageProvider</a></li></ul><h3>Interfaces</h3><ul><li><a href="IAppserviceCryptoStorageProvider.html">IAppserviceCryptoStorageProvider</a></li><li><a href="IAppserviceStorageProvider.html">IAppserviceStorageProvider</a></li><li><a href="ICryptoStorageProvider.html">ICryptoStorageProvider</a></li><li><a href="IStorageProvider.html">IStorageProvider</a></li></ul></div><div class="category"><h2>Unit testing</h2><h3>Global</h3><ul><li><a href="global.html#doHttpRequest">doHttpRequest</a></li><li><a href="global.html#getRequestFn">getRequestFn</a></li><li><a href="global.html#setRequestFn">setRequestFn</a></li></ul></div><div class="category"><h2>Unstable APIs</h2><h3>Classes</h3><ul><li><a href="UnstableApis.html">UnstableApis</a></li><li><a href="UnstableAppserviceApis.html">UnstableAppserviceApis</a></li></ul><h3>Interfaces</h3><ul><li><a href="MSC2380MediaInfo.html">MSC2380MediaInfo</a></li></ul></div><div class="category"><h2>Utilities</h2><h3>Classes</h3><ul><li><a href="DMs.html">DMs</a></li><li><a href="MatrixEntity.html">MatrixEntity</a></li><li><a href="MatrixGlob.html">MatrixGlob</a></li><li><a href="MentionPill.html">MentionPill</a></li><li><a href="Permalinks.html">Permalinks</a></li><li><a href="ProfileCache.html">ProfileCache</a></li><li><a href="RichReply.html">RichReply</a></li><li><a href="RoomAlias.html">RoomAlias</a></li><li><a href="UnpaddedBase64.html">UnpaddedBase64</a></li><li><a href="UserID.html">UserID</a></li></ul><h3>Interfaces</h3><ul><li><a href="PermalinkParts.html">PermalinkParts</a></li></ul><h3>Global</h3><ul><li><a href="global.html#decodeBase64">decodeBase64</a></li><li><a href="global.html#decodeUnpaddedBase64">decodeUnpaddedBase64</a></li><li><a href="global.html#decodeUnpaddedUrlSafeBase64">decodeUnpaddedUrlSafeBase64</a></li><li><a href="global.html#encodeBase64">encodeBase64</a></li><li><a href="global.html#encodeUnpaddedBase64">encodeUnpaddedBase64</a></li><li><a href="global.html#encodeUnpaddedUrlSafeBase64">encodeUnpaddedUrlSafeBase64</a></li><li><a href="global.html#validateSpaceOrderString">validateSpaceOrderString</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>appservice/Appservice.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as express from "express";
import { EventEmitter } from "events";
import * as morgan from "morgan";
import * as LRU from "lru-cache";
import { stringify } from "querystring";

import { Intent } from "./Intent";
import {
    AppserviceJoinRoomStrategy,
    EncryptedRoomEvent,
    EventKind,
    IAppserviceCryptoStorageProvider,
    IAppserviceStorageProvider,
    IJoinRoomStrategy,
    IPreprocessor,
    LogService,
    MatrixClient,
    MemoryStorageProvider,
    Metrics,
    MSC3983KeyClaimResponse,
    MSC3984KeyQueryResponse,
    OTKAlgorithm,
    redactObjectForLogging,
    UserID,
} from "..";
import { MatrixBridge } from "./MatrixBridge";
import { IApplicationServiceProtocol } from "./http_responses";

const EDU_ANNOTATION_KEY = "io.t2bot.sdk.bot.type";

enum EduAnnotation {
    ToDevice = "to_device",
    Ephemeral = "ephemeral",
}

/**
 * Represents an application service's registration file. This is expected to be
 * loaded from another source, such as a YAML file.
 * @category Application services
 */
export interface IAppserviceRegistration {
    /**
     * Optional ID for the appplication service. Used by homeservers to track which application
     * service registers what.
     */
    id?: string;

    /**
     * Optional URL at which the application service can be contacted.
     */
    url?: string;

    /**
     * The token the application service uses to communicate with the homeserver.
     */
    as_token: string;

    /**
     * The token the homeserver uses to communicate with the application service.
     */
    hs_token: string;

    /**
     * The application service's own localpart (eg: "_irc_bot" in the user ID "@_irc_bot:domain.com")
     */
    sender_localpart: string;

    /**
     * The various namespaces the application service can support.
     */
    namespaces: {
        /**
         * The user namespaces the application service is requesting.
         */
        users: {
            /**
             * Whether or not the application service holds an exclusive lock on the namespace. This
             * means that no other user on the homeserver may register users that match this namespace.
             */
            exclusive: boolean;

            /**
             * The regular expression that the homeserver uses to determine if a user is in this namespace.
             */
            regex: string;
        }[];

        /**
         * The room namespaces the application service is requesting. This is not for alises.
         */
        rooms: {
            /**
             * Whether or not the application service holds an exclusive lock on the namespace.
             */
            exclusive: boolean;

            /**
             * The regular expression that the homeserver uses to determine if a user is in this namespace.
             */
            regex: string;
        }[];

        /**
         * The room alias namespaces the application service is requesting.
         */
        aliases: {
            /**
             * Whether or not the application service holds an exclusive lock on the namespace. This means
             * that no other user on the homeserver may register aliases that match this namespace.
             */
            exclusive: boolean;

            /**
             * The regular expression that the homeserver uses to determine if an alias is in this namespace.
             */
            regex: string;
        }[];
    };

    /**
     * The protocols the application service supports. Optional.
     */
    protocols?: string[];

    /**
     * If the application service is rate limited by the homeserver. Optional.
     */
    rate_limited?: boolean;

    /**
     * **Experimental**
     *
     * Should the application service receive ephemeral events from the homeserver. Optional.
     * @see https://github.com/matrix-org/matrix-doc/pull/2409
     */
    "de.sorunome.msc2409.push_ephemeral"?: boolean;

    // not interested in other options
}

/**
 * General options for the application service
 * @category Application services
 */
export interface IAppserviceOptions {
    /**
     * The port to listen for requests from the homeserver on.
     */
    port: number;

    /**
     * The bind address to listen for requests on.
     */
    bindAddress: string;

    /**
     * The name of the homeserver, as presented over federation (eg: "matrix.org")
     */
    homeserverName: string;

    /**
     * The URL to the homeserver's client server API (eg: "https://matrix.org")
     */
    homeserverUrl: string;

    /**
     * The storage provider to use for this application service.
     */
    storage?: IAppserviceStorageProvider;

    /**
     * The storage provider to use for setting up encryption. Encryption will be
     * disabled for all intents and the appservice if not configured.
     */
    cryptoStorage?: IAppserviceCryptoStorageProvider;

    /**
     * The registration for this application service.
     */
    registration: IAppserviceRegistration;

    /**
     * The join strategy to use for all intents, if any.
     */
    joinStrategy?: IJoinRoomStrategy;

    /**
     * Options for how Intents are handled.
     */
    intentOptions?: {
        /**
         * The maximum number of intents to keep cached. Defaults to 10 thousand.
         */
        maxCached?: number;

        /**
         * The maximum age in milliseconds to keep an Intent around for, provided
         * the maximum number of intents has been reached. Defaults to 60 minutes.
         */
        maxAgeMs?: number;

        /**
         * If false (default), crypto will not be automatically set up for all intent
         * instances - it will need to be manually enabled with
         * `await intent.enableEncryption()`.
         *
         * If true, crypto will be automatically set up.
         *
         * Note that the appservice bot account is considered an intent.
         */
        encryption?: boolean;
    };
}

/**
 * Represents an application service. This provides helper utilities such as tracking
 * of user intents (clients that are aware of their membership in rooms).
 * @category Application services
 */
export class Appservice extends EventEmitter {
    /**
     * The metrics instance for this appservice. This will raise all metrics
     * from this appservice instance as well as any intents/MatrixClients created
     * by the appservice.
     */
    public readonly metrics: Metrics = new Metrics();

    private readonly userPrefix: string | null;
    private readonly aliasPrefix: string | null;
    private readonly registration: IAppserviceRegistration;
    private readonly storage: IAppserviceStorageProvider;
    private readonly cryptoStorage: IAppserviceCryptoStorageProvider;
    private readonly bridgeInstance = new MatrixBridge(this);

    private app = express();
    private appServer: any;
    private intentsCache: LRU&lt;string, Intent>;
    private eventProcessors: { [eventType: string]: IPreprocessor[] } = {};
    private pendingTransactions: { [txnId: string]: Promise&lt;any> } = {};

    /**
     * Creates a new application service.
     * @param {IAppserviceOptions} options The options for the application service.
     */
    constructor(private options: IAppserviceOptions) {
        super();

        options.joinStrategy = new AppserviceJoinRoomStrategy(options.joinStrategy, this);

        if (!options.intentOptions) options.intentOptions = {};
        if (!options.intentOptions.maxAgeMs) options.intentOptions.maxAgeMs = 60 * 60 * 1000;
        if (!options.intentOptions.maxCached) options.intentOptions.maxCached = 10000;

        this.intentsCache = new LRU({
            max: options.intentOptions.maxCached,
            ttl: options.intentOptions.maxAgeMs,
        });

        this.registration = options.registration;

        // If protocol is not defined, define an empty array.
        if (!this.registration.protocols) {
            this.registration.protocols = [];
        }

        this.storage = options.storage || new MemoryStorageProvider();
        options.storage = this.storage;
        this.cryptoStorage = options.cryptoStorage;

        this.app.use(express.json({ limit: Number.MAX_SAFE_INTEGER })); // disable limits, use a reverse proxy
        morgan.token('url-safe', (req: express.Request) =>
            `${req.path}?${stringify(redactObjectForLogging(req.query ?? {}))}`,
        );

        this.app.use(morgan(
            // Same as "combined", but with sensitive values removed from requests.
            ':remote-addr - :remote-user [:date[clf]] ":method :url-safe HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"',
            { stream: { write: LogService.info.bind(LogService, 'Appservice') } },
        ));

        // ETag headers break the tests sometimes, and we don't actually need them anyways for
        // appservices - none of this should be cached.
        this.app.set('etag', false);

        this.app.get("/users/:userId", this.onUser.bind(this));
        this.app.get("/rooms/:roomAlias", this.onRoomAlias.bind(this));
        this.app.put("/transactions/:txnId", this.onTransaction.bind(this));
        this.app.get("/_matrix/app/v1/users/:userId", this.onUser.bind(this));
        this.app.get("/_matrix/app/v1/rooms/:roomAlias", this.onRoomAlias.bind(this));
        this.app.put("/_matrix/app/v1/transactions/:txnId", this.onTransaction.bind(this));
        this.app.get("/_matrix/app/v1/thirdparty/protocol/:protocol", this.onThirdpartyProtocol.bind(this));
        this.app.get("/_matrix/app/v1/thirdparty/user/:protocol", this.onThirdpartyUser.bind(this));
        this.app.get("/_matrix/app/v1/thirdparty/user", this.onThirdpartyUser.bind(this));
        this.app.get("/_matrix/app/v1/thirdparty/location/:protocol", this.onThirdpartyLocation.bind(this));
        this.app.get("/_matrix/app/v1/thirdparty/location", this.onThirdpartyLocation.bind(this));
        this.app.post("/_matrix/app/unstable/org.matrix.msc3983/keys/claim", this.onKeysClaim.bind(this));
        this.app.post("/_matrix/app/unstable/org.matrix.msc3984/keys/query", this.onKeysQuery.bind(this));

        // Workaround for https://github.com/matrix-org/synapse/issues/3780
        this.app.post("/_matrix/app/v1/unstable/org.matrix.msc3983/keys/claim", this.onKeysClaim.bind(this));
        this.app.post("/unstable/org.matrix.msc3983/keys/claim", this.onKeysClaim.bind(this));
        this.app.post("/_matrix/app/v1/unstable/org.matrix.msc3984/keys/query", this.onKeysQuery.bind(this));
        this.app.post("/unstable/org.matrix.msc3984/keys/query", this.onKeysQuery.bind(this));

        // Everything else should 404
        // Technically, according to https://spec.matrix.org/v1.6/application-service-api/#unknown-routes we should
        // be returning 405 for *known* endpoints with the wrong method.
        this.app.all("*", (req: express.Request, res: express.Response) => {
            res.status(404).json({ errcode: "M_UNRECOGNIZED", error: "Endpoint not implemented" });
        });

        if (!this.registration.namespaces || !this.registration.namespaces.users || this.registration.namespaces.users.length === 0) {
            throw new Error("No user namespaces in registration");
        }
        if (this.registration.namespaces.users.length !== 1) {
            throw new Error("Too many user namespaces registered: expecting exactly one");
        }

        const userPrefix = (this.registration.namespaces.users[0].regex || "").split(":")[0];
        if (!userPrefix.endsWith(".*") &amp;&amp; !userPrefix.endsWith(".+")) {
            this.userPrefix = null;
        } else {
            this.userPrefix = userPrefix.substring(0, userPrefix.length - 2); // trim off the .* part
        }

        if (!this.registration.namespaces?.aliases || this.registration.namespaces.aliases.length !== 1) {
            this.aliasPrefix = null;
        } else {
            this.aliasPrefix = (this.registration.namespaces.aliases[0].regex || "").split(":")[0];
            if (!this.aliasPrefix.endsWith(".*") &amp;&amp; !this.aliasPrefix.endsWith(".+")) {
                this.aliasPrefix = null;
            } else {
                this.aliasPrefix = this.aliasPrefix.substring(0, this.aliasPrefix.length - 2); // trim off the .* part
            }
        }
    }

    /**
     * Gets the express app instance which is serving requests. Not recommended for
     * general usage, but may be used to append routes to the web server.
     */
    public get expressAppInstance() {
        return this.app;
    }

    /**
     * Gets the bridge-specific APIs for this application service.
     */
    public get bridge(): MatrixBridge {
        return this.bridgeInstance;
    }

    /**
     * Get the application service's "bot" user ID (the sender_localpart).
     */
    public get botUserId(): string {
        return this.getUserId(this.registration.sender_localpart);
    }

    /**
     * Get the application service's "bot" Intent (the sender_localpart).
     * @returns {Intent} The intent for the application service itself.
     */
    public get botIntent(): Intent {
        return this.getIntentForUserId(this.botUserId);
    }

    /**
     * Get the application service's "bot" MatrixClient (the sender_localpart).
     * Normally the botIntent should be used to ensure that the bot user is safely
     * handled.
     * @returns {MatrixClient} The client for the application service itself.
     */
    public get botClient(): MatrixClient {
        return this.botIntent.underlyingClient;
    }

    /**
     * Starts the application service, opening the bind address to begin processing requests.
     * @returns {Promise&lt;void>} resolves when started
     */
    public begin(): Promise&lt;void> {
        return new Promise&lt;void>((resolve, reject) => {
            this.appServer = this.app.listen(this.options.port, this.options.bindAddress, () => resolve());
        }).then(async () => {
            if (this.options.intentOptions?.encryption) {
                await this.botIntent.enableEncryption();
            } else {
                await this.botIntent.ensureRegistered();
            }
        });
    }

    /**
     * Stops the application service, freeing the web server.
     */
    public stop(): void {
        if (!this.appServer) return;
        this.appServer.close();
    }

    /**
     * Gets an intent for a given localpart. The user ID will be formed with the domain name given
     * in the constructor.
     * @param localpart The localpart to get an Intent for.
     * @returns {Intent} An Intent for the user.
     */
    public getIntent(localpart: string): Intent {
        return this.getIntentForUserId(this.getUserId(localpart));
    }

    /**
     * Gets a full user ID for a given localpart. The user ID will be formed with the domain name given
     * in the constructor.
     * @param localpart The localpart to get a user ID for.
     * @returns {string} The user's ID.
     */
    public getUserId(localpart: string): string {
        return `@${localpart}:${this.options.homeserverName}`;
    }

    /**
     * Gets an Intent for a given user suffix. The prefix is automatically detected from the registration
     * options.
     * @param suffix The user's suffix
     * @returns {Intent} An Intent for the user.
     */
    public getIntentForSuffix(suffix: string): Intent {
        return this.getIntentForUserId(this.getUserIdForSuffix(suffix));
    }

    /**
     * Gets a full user ID for a given suffix. The prefix is automatically detected from the registration
     * options.
     * @param suffix The user's suffix
     * @returns {string} The user's ID.
     */
    public getUserIdForSuffix(suffix: string): string {
        if (!this.userPrefix) {
            throw new Error(`Cannot use getUserIdForSuffix, provided namespace did not include a valid suffix`);
        }
        return `${this.userPrefix}${suffix}:${this.options.homeserverName}`;
    }

    /**
     * Gets an Intent for a given user ID.
     * @param {string} userId The user ID to get an Intent for.
     * @returns {Intent} An Intent for the user.
     */
    public getIntentForUserId(userId: string): Intent {
        let intent: Intent = this.intentsCache.get(userId);
        if (!intent) {
            intent = new Intent(this.options, userId, this);
            this.intentsCache.set(userId, intent);
            if (this.options.intentOptions.encryption) {
                intent.enableEncryption().catch(e => {
                    LogService.error("Appservice", `Failed to set up crypto on intent ${userId}`, e);
                    throw e; // re-throw to cause unhandled exception
                });
            }
        }
        return intent;
    }

    /**
     * Gets the suffix for the provided user ID. If the user ID is not a namespaced
     * user, this will return a falsey value.
     * @param {string} userId The user ID to parse
     * @returns {string} The suffix from the user ID.
     */
    public getSuffixForUserId(userId: string): string {
        if (!this.userPrefix) {
            throw new Error(`Cannot use getUserIdForSuffix, provided namespace did not include a valid suffix`);
        }
        if (!userId || !userId.startsWith(this.userPrefix) || !userId.endsWith(`:${this.options.homeserverName}`)) {
            // Invalid ID
            return null;
        }

        return userId
            .split('')
            .slice(this.userPrefix.length)
            .reverse()
            .slice(this.options.homeserverName.length + 1)
            .reverse()
            .join('');
    }

    /**
     * Determines if a given user ID is namespaced by this application service.
     * @param {string} userId The user ID to check
     * @returns {boolean} true if the user is namespaced, false otherwise
     */
    public isNamespacedUser(userId: string): boolean {
        return userId === this.botUserId ||
            !!this.registration.namespaces?.users.find(({ regex }) =>
                new RegExp(regex).test(userId),
            );
    }

    /**
     * Gets a full alias for a given localpart. The alias will be formed with the domain name given
     * in the constructor.
     * @param localpart The localpart to get an alias for.
     * @returns {string} The alias.
     */
    public getAlias(localpart: string): string {
        return `#${localpart}:${this.options.homeserverName}`;
    }

    /**
     * Gets a full alias for a given suffix. The prefix is automatically detected from the registration
     * options.
     * @param suffix The alias's suffix
     * @returns {string} The alias.
     */
    public getAliasForSuffix(suffix: string): string {
        if (!this.aliasPrefix) {
            throw new Error("Invalid configured alias prefix");
        }
        return `${this.aliasPrefix}${suffix}:${this.options.homeserverName}`;
    }

    /**
     * Gets the localpart of an alias for a given suffix. The prefix is automatically detected from the registration
     * options. Useful for the createRoom endpoint.
     * @param suffix The alias's suffix
     * @returns {string} The alias localpart.
     */
    public getAliasLocalpartForSuffix(suffix: string): string {
        if (!this.aliasPrefix) {
            throw new Error("Invalid configured alias prefix");
        }
        return `${this.aliasPrefix.substr(1)}${suffix}`;
    }

    /**
     * Gets the suffix for the provided alias. If the alias is not a namespaced
     * alias, this will return a falsey value.
     * @param {string} alias The alias to parse
     * @returns {string} The suffix from the alias.
     */
    public getSuffixForAlias(alias: string): string {
        if (!this.aliasPrefix) {
            throw new Error("Invalid configured alias prefix");
        }
        if (!alias || !this.isNamespacedAlias(alias)) {
            // Invalid ID
            return null;
        }

        return alias
            .split('')
            .slice(this.aliasPrefix.length)
            .reverse()
            .slice(this.options.homeserverName.length + 1)
            .reverse()
            .join('');
    }

    /**
     * Determines if a given alias is namespaced by this application service.
     * @param {string} alias The alias to check
     * @returns {boolean} true if the alias is namespaced, false otherwise
     */
    public isNamespacedAlias(alias: string): boolean {
        if (!this.aliasPrefix) {
            throw new Error("Invalid configured alias prefix");
        }
        return alias.startsWith(this.aliasPrefix) &amp;&amp; alias.endsWith(":" + this.options.homeserverName);
    }

    /**
     * Adds a preprocessor to the event pipeline. When this appservice encounters an event, it
     * will try to run it through the preprocessors it can in the order they were added.
     * @param {IPreprocessor} preprocessor the preprocessor to add
     */
    public addPreprocessor(preprocessor: IPreprocessor): void {
        if (!preprocessor) throw new Error("Preprocessor cannot be null");

        const eventTypes = preprocessor.getSupportedEventTypes();
        if (!eventTypes) return; // Nothing to do

        for (const eventType of eventTypes) {
            if (!this.eventProcessors[eventType]) this.eventProcessors[eventType] = [];
            this.eventProcessors[eventType].push(preprocessor);
        }
    }

    /**
     * Sets the visibility of a room in the appservice's room directory.
     * @param {string} networkId The network ID to group the room under.
     * @param {string} roomId The room ID to manipulate the visibility of.
     * @param {"public" | "private"} visibility The visibility to set for the room.
     * @return {Promise&lt;any>} resolves when the visibility has been updated.
     */
    public setRoomDirectoryVisibility(networkId: string, roomId: string, visibility: "public" | "private") {
        roomId = encodeURIComponent(roomId);
        networkId = encodeURIComponent(networkId);
        return this.botClient.doRequest("PUT", `/_matrix/client/v3/directory/list/appservice/${networkId}/${roomId}`, null, {
            visibility,
        });
    }

    private async processEphemeralEvent(event: any): Promise&lt;any> {
        if (!event) return event;
        if (!this.eventProcessors[event["type"]]) return event;

        for (const processor of this.eventProcessors[event["type"]]) {
            await processor.processEvent(event, this.botIntent.underlyingClient, EventKind.EphemeralEvent);
        }

        return event;
    }

    private async processEvent(event: any): Promise&lt;any> {
        if (!event) return event;
        if (!this.eventProcessors[event["type"]]) return event;

        for (const processor of this.eventProcessors[event["type"]]) {
            await processor.processEvent(event, this.botIntent.underlyingClient, EventKind.RoomEvent);
        }

        return event;
    }

    private async processMembershipEvent(event: any): Promise&lt;void> {
        if (!event["content"]) return;

        const domain = new UserID(event['state_key']).domain;
        const botDomain = new UserID(this.botUserId).domain;
        if (domain !== botDomain) return; // can't be impersonated, so don't try

        // Update the target intent's joined rooms (fixes transition errors with the cache, like join->kick->join)
        const intent = this.getIntentForUserId(event['state_key']);
        await intent.refreshJoinedRooms();

        const targetMembership = event["content"]["membership"];
        if (targetMembership === "join") {
            this.emit("room.join", event["room_id"], event);
            await intent.underlyingClient.crypto?.onRoomJoin(event["room_id"]);
        } else if (targetMembership === "ban" || targetMembership === "leave") {
            this.emit("room.leave", event["room_id"], event);
        } else if (targetMembership === "invite") {
            this.emit("room.invite", event["room_id"], event);
        }
    }

    private isAuthed(req: any): boolean {
        let providedToken = req.query ? req.query["access_token"] : null;
        if (req.headers &amp;&amp; req.headers["authorization"]) {
            const authHeader = req.headers["authorization"];
            if (!authHeader.startsWith("Bearer ")) providedToken = null;
            else providedToken = authHeader.substring("Bearer ".length);
        }

        return providedToken === this.registration.hs_token;
    }

    private async onTransaction(req: express.Request, res: express.Response): Promise&lt;any> {
        if (!this.isAuthed(req)) {
            res.status(401).json({ errcode: "AUTH_FAILED", error: "Authentication failed" });
            return;
        }

        if (typeof (req.body) !== "object") {
            res.status(400).json({ errcode: "BAD_REQUEST", error: "Expected JSON" });
            return;
        }

        if (!req.body["events"] || !Array.isArray(req.body["events"])) {
            res.status(400).json({ errcode: "BAD_REQUEST", error: "Invalid JSON: expected events" });
            return;
        }

        const txnId = req.params["txnId"];

        if (await Promise.resolve(this.storage.isTransactionCompleted(txnId))) {
            res.status(200).json({});
            return;
        }

        if (this.pendingTransactions[txnId]) {
            try {
                await this.pendingTransactions[txnId];
                res.status(200).json({});
            } catch (e) {
                LogService.error("Appservice", e);
                res.status(500).json({});
            }
            return;
        }

        LogService.info("Appservice", "Processing transaction " + txnId);
        // eslint-disable-next-line no-async-promise-executor
        this.pendingTransactions[txnId] = new Promise&lt;void>(async (resolve) => {
            // Process all the crypto stuff first to ensure that future transactions (if not this one)
            // will decrypt successfully. We start with EDUs because we need structures to put counts
            // and such into in a later stage, and EDUs are independent of crypto.

            const byUserId: {
                [userId: string]: {
                    counts: Record&lt;string, Number>;
                    toDevice: any[];
                    unusedFallbacks: OTKAlgorithm[];
                };
            } = {};

            const orderedEdus = [];
            if (Array.isArray(req.body["de.sorunome.msc2409.to_device"])) {
                orderedEdus.push(...req.body["de.sorunome.msc2409.to_device"].map(e => ({
                    ...e,
                    unsigned: {
                        ...e['unsigned'],
                        [EDU_ANNOTATION_KEY]: EduAnnotation.ToDevice,
                    },
                })));
            }
            if (Array.isArray(req.body["de.sorunome.msc2409.ephemeral"])) {
                orderedEdus.push(...req.body["de.sorunome.msc2409.ephemeral"].map(e => ({
                    ...e,
                    unsigned: {
                        ...e['unsigned'],
                        [EDU_ANNOTATION_KEY]: EduAnnotation.Ephemeral,
                    },
                })));
            }
            for (let event of orderedEdus) {
                if (event['edu_type']) event['type'] = event['edu_type']; // handle property change during MSC2409's course

                LogService.info("Appservice", `Processing ${event['unsigned'][EDU_ANNOTATION_KEY]} event of type ${event["type"]}`);
                event = await this.processEphemeralEvent(event);

                // These events aren't tied to rooms, so just emit them generically
                this.emit("ephemeral.event", event);

                if (this.cryptoStorage &amp;&amp; (event["type"] === "m.room.encrypted" || event.unsigned?.[EDU_ANNOTATION_KEY] === EduAnnotation.ToDevice)) {
                    const toUser = event["to_user_id"];
                    const intent = this.getIntentForUserId(toUser);
                    await intent.enableEncryption();

                    if (!byUserId[toUser]) byUserId[toUser] = { counts: null, toDevice: null, unusedFallbacks: null };
                    if (!byUserId[toUser].toDevice) byUserId[toUser].toDevice = [];
                    byUserId[toUser].toDevice.push(event);
                }
            }

            const deviceLists: { changed: string[], removed: string[] } = req.body["org.matrix.msc3202.device_lists"] ?? {
                changed: [],
                removed: [],
            };

            if (!deviceLists.changed) deviceLists.changed = [];
            if (!deviceLists.removed) deviceLists.removed = [];

            if (deviceLists.changed.length || deviceLists.removed.length) {
                this.emit("device_lists", deviceLists);
            }

            let otks = req.body["org.matrix.msc3202.device_one_time_keys_count"];
            const otks2 = req.body["org.matrix.msc3202.device_one_time_key_counts"];
            if (otks2 &amp;&amp; !otks) {
                LogService.warn(
                    "Appservice",
                    "Your homeserver is using an outdated field (device_one_time_key_counts) to talk to this appservice. " +
                    "If you're using Synapse, please upgrade to 1.73.0 or higher.",
                );
                otks = otks2;
            }
            if (otks) {
                this.emit("otk.counts", otks);
            }
            if (otks &amp;&amp; this.cryptoStorage) {
                for (const userId of Object.keys(otks)) {
                    const intent = this.getIntentForUserId(userId);
                    await intent.enableEncryption();
                    const otksForUser = otks[userId][intent.underlyingClient.crypto.clientDeviceId];
                    if (otksForUser) {
                        if (!byUserId[userId]) {
                            byUserId[userId] = {
                                counts: null,
                                toDevice: null,
                                unusedFallbacks: null,
                            };
                        }
                        byUserId[userId].counts = otksForUser;
                    }
                }
            }

            const fallbacks = req.body["org.matrix.msc3202.device_unused_fallback_key_types"];
            if (fallbacks) {
                this.emit("otk.unused_fallback_keys", fallbacks);
            }
            if (fallbacks &amp;&amp; this.cryptoStorage) {
                for (const userId of Object.keys(fallbacks)) {
                    const intent = this.getIntentForUserId(userId);
                    await intent.enableEncryption();
                    const fallbacksForUser = fallbacks[userId][intent.underlyingClient.crypto.clientDeviceId];
                    if (Array.isArray(fallbacksForUser) &amp;&amp; !fallbacksForUser.includes(OTKAlgorithm.Signed)) {
                        if (!byUserId[userId]) {
                            byUserId[userId] = {
                                counts: null,
                                toDevice: null,
                                unusedFallbacks: null,
                            };
                        }
                        byUserId[userId].unusedFallbacks = fallbacksForUser;
                    }
                }
            }

            if (this.cryptoStorage) {
                for (const userId of Object.keys(byUserId)) {
                    const intent = this.getIntentForUserId(userId);
                    await intent.enableEncryption();
                    const info = byUserId[userId];
                    const userStorage = this.storage.storageForUser(userId);

                    if (!info.toDevice) info.toDevice = [];
                    if (!info.unusedFallbacks) info.unusedFallbacks = JSON.parse(await userStorage.readValue("last_unused_fallbacks") || "[]");
                    if (!info.counts) info.counts = JSON.parse(await userStorage.readValue("last_counts") || "{}");

                    LogService.info("Appservice", `Updating crypto state for ${userId}`);
                    await intent.underlyingClient.crypto.updateSyncData(info.toDevice, info.counts, info.unusedFallbacks, deviceLists.changed, deviceLists.removed);
                }
            }

            for (let event of req.body["events"]) {
                LogService.info("Appservice", `Processing event of type ${event["type"]}`);
                event = await this.processEvent(event);
                if (event['type'] === 'm.room.encrypted') {
                    this.emit("room.encrypted_event", event["room_id"], event);
                    if (this.cryptoStorage) {
                        try {
                            const encrypted = new EncryptedRoomEvent(event);
                            const roomId = event['room_id'];
                            try {
                                event = (await this.botClient.crypto.decryptRoomEvent(encrypted, roomId)).raw;
                                event = await this.processEvent(event);
                                this.emit("room.decrypted_event", roomId, event);

                                // For logging purposes: show that the event was decrypted
                                LogService.info("Appservice", `Processing decrypted event of type ${event["type"]}`);
                            } catch (e1) {
                                LogService.warn("Appservice", `Bot client was not able to decrypt ${roomId} ${event['event_id']} - trying other intents`);

                                let tryUserId: string;
                                try {
                                    // TODO: This could be more efficient
                                    const userIdsInRoom = await this.botClient.getJoinedRoomMembers(roomId);
                                    tryUserId = userIdsInRoom.find(u => this.isNamespacedUser(u));
                                } catch (e) {
                                    LogService.error("Appservice", "Failed to get members of room - cannot decrypt message");
                                }

                                if (tryUserId) {
                                    const intent = this.getIntentForUserId(tryUserId);

                                    event = (await intent.underlyingClient.crypto.decryptRoomEvent(encrypted, roomId)).raw;
                                    event = await this.processEvent(event);
                                    this.emit("room.decrypted_event", roomId, event);

                                    // For logging purposes: show that the event was decrypted
                                    LogService.info("Appservice", `Processing decrypted event of type ${event["type"]}`);
                                } else {
                                    // noinspection ExceptionCaughtLocallyJS
                                    throw e1;
                                }
                            }
                        } catch (e) {
                            LogService.error("Appservice", `Decryption error on ${event['room_id']} ${event['event_id']}`, e);
                            this.emit("room.failed_decryption", event['room_id'], event, e);
                        }
                    }
                }
                this.emit("room.event", event["room_id"], event);
                if (event['type'] === 'm.room.message') {
                    this.emit("room.message", event["room_id"], event);
                }
                if (event['type'] === 'm.room.member' &amp;&amp; this.isNamespacedUser(event['state_key'])) {
                    await this.processMembershipEvent(event);
                }
                if (event['type'] === 'm.room.tombstone' &amp;&amp; event['state_key'] === '') {
                    this.emit("room.archived", event['room_id'], event);
                }
                if (event['type'] === 'm.room.create' &amp;&amp; event['state_key'] === '' &amp;&amp; event['content'] &amp;&amp; event['content']['predecessor']) {
                    this.emit("room.upgraded", event['room_id'], event);
                }
            }

            resolve();
        });

        try {
            await this.pendingTransactions[txnId];
            await Promise.resolve(this.storage.setTransactionCompleted(txnId));
            res.status(200).json({});
        } catch (e) {
            LogService.error("Appservice", e);
            res.status(500).json({});
        }
    }

    private async onUser(req: express.Request, res: express.Response): Promise&lt;any> {
        if (!this.isAuthed(req)) {
            res.status(401).json({ errcode: "AUTH_FAILED", error: "Authentication failed" });
            return;
        }

        const userId = req.params["userId"];
        this.emit("query.user", userId, async (result) => {
            if (result.then) result = await result;
            if (result === false) {
                res.status(404).json({ errcode: "USER_DOES_NOT_EXIST", error: "User not created" });
            } else {
                const intent = this.getIntentForUserId(userId);
                await intent.ensureRegistered();
                if (result.display_name) await intent.underlyingClient.setDisplayName(result.display_name);
                if (result.avatar_mxc) await intent.underlyingClient.setAvatarUrl(result.avatar_mxc);
                res.status(200).json(result); // return result for debugging + testing
            }
        });
    }

    private async onRoomAlias(req: express.Request, res: express.Response): Promise&lt;any> {
        if (!this.isAuthed(req)) {
            res.status(401).json({ errcode: "AUTH_FAILED", error: "Authentication failed" });
            return;
        }

        const roomAlias = req.params["roomAlias"];
        this.emit("query.room", roomAlias, async (result) => {
            if (result.then) result = await result;
            if (result === false) {
                res.status(404).json({ errcode: "ROOM_DOES_NOT_EXIST", error: "Room not created" });
            } else {
                const intent = this.botIntent;
                await intent.ensureRegistered();

                result["room_alias_name"] = roomAlias.substring(1).split(':')[0];
                result["__roomId"] = await intent.underlyingClient.createRoom(result);

                res.status(200).json(result); // return result for debugging + testing
            }
        });
    }

    private async onKeysClaim(req: express.Request, res: express.Response): Promise&lt;any> {
        if (!this.isAuthed(req)) {
            res.status(401).json({ errcode: "AUTH_FAILED", error: "Authentication failed" });
            return;
        }

        if (typeof (req.body) !== "object") {
            res.status(400).json({ errcode: "BAD_REQUEST", error: "Expected JSON" });
            return;
        }

        let responded = false;
        this.emit("query.key_claim", req.body, (result: MSC3983KeyClaimResponse | Promise&lt;MSC3983KeyClaimResponse> | undefined | null) => {
            responded = true;

            const handleResult = (result2: MSC3983KeyClaimResponse) => {
                if (!result2) {
                    res.status(404).json({ errcode: "M_UNRECOGNIZED", error: "Endpoint not implemented" });
                    return;
                }

                res.status(200).json(result2);
            };

            Promise.resolve(result).then(r => handleResult(r)).catch(e => {
                LogService.error("Appservice", "Error handling key claim API", e);
                res.status(500).json({ errcode: "M_UNKNOWN", error: "Error handling key claim API" });
            });
        });
        if (!responded) {
            res.status(404).json({ errcode: "M_UNRECOGNIZED", error: "Endpoint not implemented" });
        }
    }

    private async onKeysQuery(req: express.Request, res: express.Response): Promise&lt;any> {
        if (!this.isAuthed(req)) {
            res.status(401).json({ errcode: "AUTH_FAILED", error: "Authentication failed" });
            return;
        }

        if (typeof (req.body) !== "object") {
            res.status(400).json({ errcode: "BAD_REQUEST", error: "Expected JSON" });
            return;
        }

        let responded = false;
        this.emit("query.key", req.body, (result: MSC3984KeyQueryResponse | Promise&lt;MSC3984KeyQueryResponse> | undefined | null) => {
            responded = true;

            const handleResult = (result2: MSC3984KeyQueryResponse) => {
                if (!result2) {
                    res.status(404).json({ errcode: "M_UNRECOGNIZED", error: "Endpoint not implemented" });
                    return;
                }

                // Implementation note: we could probably query the device keys from our storage if we wanted to.

                res.status(200).json(result2);
            };

            Promise.resolve(result).then(r => handleResult(r)).catch(e => {
                LogService.error("Appservice", "Error handling key query API", e);
                res.status(500).json({ errcode: "M_UNKNOWN", error: "Error handling key query API" });
            });
        });
        if (!responded) {
            res.status(404).json({ errcode: "M_UNRECOGNIZED", error: "Endpoint not implemented" });
        }
    }

    private onThirdpartyProtocol(req: express.Request, res: express.Response) {
        if (!this.isAuthed(req)) {
            res.status(401).json({ errcode: "AUTH_FAILED", error: "Authentication failed" });
            return;
        }

        const protocol = req.params["protocol"];
        if (!this.registration.protocols.includes(protocol)) {
            res.status(404).json({
                errcode: "PROTOCOL_NOT_HANDLED",
                error: "Protocol is not handled by this appservice",
            });
            return;
        }
        this.emit("thirdparty.protocol", protocol, (protocolResponse: IApplicationServiceProtocol) => {
            res.status(200).json(protocolResponse);
        });
    }

    private handleThirdpartyObject(req: express.Request, res: express.Response, objType: string, matrixId?: string) {
        if (!this.isAuthed(req)) {
            res.status(401).json({ errcode: "AUTH_FAILED", error: "Authentication failed" });
            return;
        }

        const protocol = req.params["protocol"];
        const responseFunc = (items: any[]) => {
            if (items &amp;&amp; items.length > 0) {
                res.status(200).json(items);
                return;
            }
            res.status(404).json({
                errcode: "NO_MAPPING_FOUND",
                error: "No mappings found",
            });
        };

        // Lookup remote objects(s)
        if (protocol) { // If protocol is given, we are looking up a objects based on fields
            if (!this.registration.protocols.includes(protocol)) {
                res.status(404).json({
                    errcode: "PROTOCOL_NOT_HANDLED",
                    error: "Protocol is not handled by this appservice",
                });
                return;
            }
            // Remove the access_token
            delete req.query.access_token;
            this.emit(`thirdparty.${objType}.remote`, protocol, req.query, responseFunc);
            return;
        } else if (matrixId) { // If a user ID is given, we are looking up a remote objects based on a id
            this.emit(`thirdparty.${objType}.matrix`, matrixId, responseFunc);
            return;
        }

        res.status(400).json({
            errcode: "INVALID_PARAMETERS",
            error: "Invalid parameters given",
        });
    }

    private onThirdpartyUser(req: express.Request, res: express.Response) {
        return this.handleThirdpartyObject(req, res, "user", req.query["userid"] as string);
    }

    private onThirdpartyLocation(req: express.Request, res: express.Response) {
        return this.handleThirdpartyObject(req, res, "location", req.query["alias"] as string);
    }
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.10</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
